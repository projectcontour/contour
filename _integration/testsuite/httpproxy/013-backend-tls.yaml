# Copyright Project Contour Authors
#
# Licensed under the Apache License, Version 2.0 (the "License"); you may
# not use this file except in compliance with the License.  You may obtain
# a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
# WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the
# License for the specific language governing permissions and limitations
# under the License.

import data.contour.resources
import data.contour.resources.configmap

Namespace := "projectcontour"
Config := sprintf("%s/contour",[Namespace])

get_envoy_client_cert() = client_cert {
  conf := configmap.get_data(Config)
  contour := yaml.unmarshal(object.get(conf, "contour.yaml", "{}"))
  tls := object.get(contour, "tls", {})
  client_cert := object.get(tls, "envoy-client-certificate", {})
}

# Skip if the configmap isn't present.
skip[msg] {
  not resources.is_present("configmaps", Config)
  msg := sprintf("Contour is not installed in the %q namespace", [Namespace])
}

skip[msg] {
  client_cert := get_envoy_client_cert()
  is_null(client_cert) # envoy-client-certificate is an empty.
  msg := "Envoy client certificate is not configured"
}

skip[msg] {
  client_cert := get_envoy_client_cert()
  not is_null(client_cert)

  # Skip if there's no secret name.
  object.get(client_cert, "name", "") == ""

  msg := "Envoy client certificate is not configured"
}

---

apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: selfsigned
  namespace: 013-backend-tls
spec:
  selfSigned: {}

---

apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: ca-projectcontour-io
  namespace: 013-backend-tls
spec:
  isCA: true
  usages:
  - signing
  - cert sign
  subject:
    organizationalUnits:
    - io
    - projectcontour
    - testsuite
  commonName: issuer
  secretName: ca-projectcontour-io
  issuerRef:
    name: selfsigned

---

apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: ca-projectcontour-io
  namespace: 013-backend-tls
spec:
  ca:
    secretName: ca-projectcontour-io

---

apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: backend-server-cert
  namespace: 013-backend-tls
spec:
  commonName: echo
  usages:
  - server auth
  dnsNames:
  - echo
  secretName: backend-server-cert
  issuerRef:
    name: ca-projectcontour-io

---

apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: envoy-client-cert
  namespace: 013-backend-tls
spec:
  commonName: envoy
  usages:
  - client auth
  secretName: envoy-client-cert
  issuerRef:
    name: ca-projectcontour-io

---

apiVersion: apps/v1
kind: Deployment
metadata:
  name: ingress-conformance-echo-tls
$apply:
  fixture:
    as: 013-backend-tls/echo

---

apiVersion: v1
kind: Service
metadata:
  name: ingress-conformance-echo-tls
$apply:
  fixture:
    as: 013-backend-tls/echo

---

apiVersion: projectcontour.io/v1
kind: HTTPProxy
metadata:
  name: echo
  namespace: 013-backend-tls
spec:
  virtualhost:
    fqdn: httpproxy.projectcontour.io
  routes:
  - services:
    - name: echo
      port: 443
      validation:
        caSecret: envoy-client-cert  # Only ca.crt is used from the secret in this case.
        subjectName: echo

---

import data.contour.http.client
import data.contour.http.client.url
import data.contour.http.response
import data.contour.resources

# Request is made with HTTP, but the test case verifies that HTTPS is used between envoy and backend.
Response := client.Get({
  "url": url.http("/echo"),
  "headers": {
    "Host": "httpproxy.projectcontour.io",
    "User-Agent": client.ua("backend-tls-test"),
  },
})

EnvoySecret := resources.get("secrets", "013-backend-tls/envoy-client-cert")
EnvoyCert := base64.decode(EnvoySecret.data["tls.crt"])

error_non_200_response [msg] {
  not Response
  msg := "no response"
}

error_non_200_response [msg] {
  Response.status_code != 200
  msg := sprintf("got status %d, wanted %d", [Response.status_code, 200])
}

error_no_upstream_tls [msg] {
  not Response.body.tls
  msg := "Backend did not receive TLS connection from Envoy"
}

error_no_upstream_clientcert [msg] {
  not Response.body.tls.peerCertificates[0]
  msg := "Backend did not receive client certificate from Envoy"
}

error_wrong_tls_certificate [msg] {
  Response.body.tls.peerCertificates[0] != EnvoyCert
  msg := sprintf("Backend received wrong certificate\n- %s\n+ %s", [EnvoyCert, Response.body.tls.peerCertificates[0]])
}

---

# attach annotation to flag current secret as old, so that we can ensure new one is generated by cert-manager
apiVersion: v1
kind: Secret
metadata:
  name: envoy-client-cert
  namespace: 013-backend-tls
  annotations:
    oldSecret: "true"

---

# Delete envoy certificate to force cert-manager to rotate it.
apiVersion: v1
kind: Secret
metadata:
  name: envoy-client-cert
  namespace: 013-backend-tls
$apply: delete

---

import data.contour.resources

EnvoySecret := resources.get("secrets", "013-backend-tls/envoy-client-cert")

# Wait for secret to be actually deleted and recreated.
error_secret_not_updated [msg] {
  EnvoySecret.metadata.annotations["oldSecret"]
  msg := "Old client certificate secret still exists or was not recreated"
}

---

# Make new request after certificate was rotated. Now new certificate should be used.

import data.contour.http.client
import data.contour.http.client.url
import data.contour.http.expect
import data.contour.http.response
import data.contour.resources

# Request is made with HTTP, but the test case verifies that HTTPS is used between envoy and backend.
Response := client.Get({
  "url": url.http("/echo"),
  "headers": {
    "Host": "httpproxy.projectcontour.io",
    "User-Agent": client.ua("backend-tls-test"),
  },
})

EnvoySecret := resources.get("secrets", "013-backend-tls/envoy-client-cert")
EnvoyCert := base64.decode(EnvoySecret.data["tls.crt"])

check_for_status_code [msg] {
  msg := expect.response_status_is(Response, 200)
}

error_no_upstream_tls [msg] {
  not Response.body.tls
  msg := "Backend did not receive TLS connection from Envoy"
}

error_no_upstream_clientcert [msg] {
  not Response.body.tls.peerCertificates[0]
  msg := "Backend did not receive client certificate from Envoy"
}

error_wrong_tls_certificate [msg] {
  Response.body.tls.peerCertificates[0] != EnvoyCert
  msg := sprintf("Backend received wrong certificate\n- %s\n+ %s", [EnvoyCert, Response.body.tls.peerCertificates[0]])
}

---

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: echo
  namespace: 013-backend-tls
spec:
  rules:
    - host: ingress.projectcontour.io
      http:
        paths:
        - pathType: Prefix
          path: "/"
          backend:
            service:
              name: echo
              port:
                number: 443

---

import data.contour.http.client
import data.contour.http.client.url
import data.contour.http.expect
import data.contour.http.response
import data.contour.resources

# Request is made with HTTP, but the test case verifies that HTTPS is used between envoy and backend.
Response := client.Get({
  "url": url.http("/echo"),
  "headers": {
    "Host": "ingress.projectcontour.io",
    "User-Agent": client.ua("backend-tls-test"),
  },
})

EnvoySecret := resources.get("secrets", "013-backend-tls/envoy-client-cert")
EnvoyCert := base64.decode(EnvoySecret.data["tls.crt"])

check_for_status_code [msg] {
  msg := expect.response_status_is(Response, 200)
}

error_no_upstream_tls [msg] {
  not Response.body.tls
  msg := "Backend did not receive TLS connection from Envoy"
}

error_no_upstream_clientcert [msg] {
  not Response.body.tls.peerCertificates[0]
  msg := "Backend did not receive client certificate from Envoy"
}

error_wrong_tls_certificate [msg] {
  Response.body.tls.peerCertificates[0] != EnvoyCert
  msg := sprintf("Backend received wrong certificate\n- %s\n+ %s", [EnvoyCert, Response.body.tls.peerCertificates[0]])
}
